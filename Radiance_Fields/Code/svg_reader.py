# SVG file parser for Flatland 1D camera rendering
# Tested with svg files generated by inkscape
#
# Handles circle, rect, image
# 3-point paths are interpreted as camera FOVs
# Handles translation and rotation
#
# Rect can have property "Reflect" as scalar degree of reflectivity
#
# See install_notes for dependencies
# 
# Feb 2025 - Created for / presented at RVSS 2025 by Don Dansereau

import xml.etree.ElementTree as ET
import numpy as np
import math
from matplotlib.transforms import Affine2D
import matplotlib.pyplot as plt
import base64
from io import BytesIO
from PIL import Image

def read_svg_file(filename):
    with open(filename, 'r') as file:
        svg_content = file.read()

    root = ET.fromstring(svg_content)
    elements = []
    for elem in root.findall(".//{http://www.w3.org/2000/svg}path"): 
        if 'd' in elem.attrib:
            path_data = elem.attrib['d']
            points_data = path_data.split()
            if len(points_data) == 4:  # interpret 3-point paths as cameras
                command = points_data[0]
                if command == 'M':
                    p1 = np.array(list(map(float, points_data[1].split(','))))
                    p2 = np.array(list(map(float, points_data[2].split(','))))
                    p3 = np.array(list(map(float, points_data[3].split(','))))
                elif command == 'm':
                    p1 = np.array(list(map(float, points_data[1].split(','))))
                    p2 = p1 + np.array(list(map(float, points_data[2].split(','))))
                    p3 = p2 + np.array(list(map(float, points_data[3].split(','))))
                c = p2
                a, direction = calculate_fov(p1, p2, p3)
                elements.append(('camera', c, a, direction))
    for elem in root.findall(".//{http://www.w3.org/2000/svg}circle"):
        cx = float(elem.attrib['cx'])
        cy = float(elem.attrib['cy'])
        r = float(elem.attrib['r'])
        fill = elem.attrib.get('style', '').split('fill:')[1].split(';')[0] if 'fill:' in elem.attrib.get('style', '') else None
        elements.append(('circle', np.array([cx, cy]), r, fill))
    for elem in root.findall(".//{http://www.w3.org/2000/svg}rect"):
        x = float(elem.attrib['x'])
        y = float(elem.attrib['y'])
        width = float(elem.attrib['width'])
        height = float(elem.attrib['height'])
        transform = elem.attrib.get('transform', None)
        if transform:
            transform = parse_transform(transform)
        fill = elem.attrib.get('style', '').split('fill:')[1].split(';')[0] if 'fill:' in elem.attrib.get('style', '') else None
        reflect = float(elem.attrib.get('Reflect', 0))  # Read the Reflect property
        elements.append(('rect', np.array([x, y]), np.array([width, height]), transform, fill, reflect))
    for elem in root.findall(".//{http://www.w3.org/2000/svg}image"):
        x = float(elem.attrib['x'])
        y = float(elem.attrib['y'])
        width = float(elem.attrib['width'])
        height = float(elem.attrib['height'])
        transform = elem.attrib.get('transform', None)
        if transform:
            transform = parse_transform(transform)
        href = elem.attrib['{http://www.w3.org/1999/xlink}href']
        image_data = base64.b64decode(href.split(',')[1])
        image = Image.open(BytesIO(image_data))
        elements.append(('image', np.array([x, y]), np.array([width, height]), transform, image))
    return elements

def parse_transform(transform):
    if transform.startswith('rotate'):
        angle = float(transform.split('(')[1].split(')')[0])
        return {'rotate': angle}
    return None

def calculate_fov(p1, p2, p3):
    # Calculate field of view
    v1 = p1 - p2
    v1 = v1 / np.linalg.norm(v1)
    v2 = p3 - p2
    v2 = v2 / np.linalg.norm(v2)
    dot_product = np.dot(v1, v2)
    angle = np.arccos(dot_product)

    direction = (v1 + v2) / 2
    direction = direction / np.linalg.norm(direction)

    return np.degrees(angle), direction

def draw_elements(fig, ax,  elements):
    for element in elements:
        if element[0] == 'circle':
            _, center, radius, fill = element
            circle = plt.Circle(center, radius, color=fill if fill else 'black', fill=True, zorder=2)
            ax.add_patch(circle)
        elif element[0] == 'rect':
            _, origin, size, transform, fill, reflect = element
            rect = plt.Rectangle(origin, size[0], size[1], color=fill if fill else 'black', fill=True, zorder=2)
            if reflect != 0:
                rect.set_edgecolor('red')
                rect.set_linewidth(2)
            if transform and 'rotate' in transform:
                rectTrans = Affine2D().rotate_deg_around(0, 0, transform['rotate'])
                rect.set_transform(rectTrans + ax.transData)
            ax.add_patch(rect)
        elif element[0] == 'camera':
            _, center, angle, direction = element
            ax.plot(center[0], center[1], 'ko', zorder=3)  # Placeholder for camera representation
            draw_fov(ax, center, angle, direction)
        elif element[0] == 'image':
            _, origin, size, transform, image = element
            print(transform)
            if transform and 'rotate' in transform:
                imgTrans = Affine2D().rotate_deg_around(0, 0, transform['rotate'])       
                ax.imshow(image, 
                    extent=[origin[0], origin[0] + size[0], origin[1], origin[1] + size[1]], 
                    origin='lower', 
                    zorder=-1, 
                    transform=imgTrans + ax.transData) # Combine with data transform               
            else:
                ax.imshow(image, extent=[origin[0], origin[0] + size[0], origin[1], origin[1] + size[1]], origin='lower', zorder=-1)

    return fig, ax

def draw_fov(ax, center, angle, direction, fov_display_size = 20):
    # Draw the FOV as two lines originating from the center
    half_angle = np.radians(angle / 2)
    left_endpoint = center + fov_display_size * np.array([np.cos(half_angle), np.sin(half_angle)]) @ np.array([[direction[0], direction[1]], [-direction[1], direction[0]]])
    right_endpoint = center + fov_display_size * np.array([np.cos(-half_angle), np.sin(-half_angle)]) @ np.array([[direction[0], direction[1]], [-direction[1], direction[0]]])
    ax.plot([center[0], left_endpoint[0]], [center[1], left_endpoint[1]], 'k', zorder=3)
    ax.plot([center[0], right_endpoint[0]], [center[1], right_endpoint[1]], 'k', zorder=3)

def find_intersection(elements, ray, recursion_depth = 0):
    origin, direction = ray
    closest_intersection = None
    min_distance = float('inf')
    min_valid_distance = 0.01
    intersection_color = None

    for element in elements:
        if element[0] == 'circle':
            _, center, radius, fill = element
            intersection = intersect_ray_circle(origin, direction, center, radius)
            color = tuple(int(fill[i:i+2], 16) for i in (1, 3, 5))
        elif element[0] == 'rect':
            _, origin_rect, size, transform, fill, reflect = element
            intersection = intersect_ray_rect(origin, direction, origin_rect, size, transform)
            color = tuple(int(fill[i:i+2], 16) for i in (1, 3, 5))

            # Check for and compute reflection
            if intersection is not None and reflect != 0 and recursion_depth < 1:
                normal = np.array([0, 1])
                if transform and 'rotate' in transform:
                    angle = np.radians(transform['rotate'])
                    rotation_matrix = np.array([[np.cos(angle), -np.sin(angle)], [np.sin(angle), np.cos(angle)]])
                    normal = np.dot(rotation_matrix, normal)
                reflection = direction - 2 * np.dot(direction, normal) * normal
                reflection = reflection / np.linalg.norm(reflection)
                reflection_intersection = intersection
                reflection_intersection, reflected_color = find_intersection(elements, (reflection_intersection, reflection), recursion_depth+1)
                if reflected_color is not None:
                    color = tuple(c + reflect * rc for c, rc in zip(color, reflected_color))

        elif element[0] == 'image':
            _, origin_img, size, transform, image = element
            intersection = intersect_ray_rect(origin, direction, origin_img, size, transform)
            if intersection is not None:
                color = get_image_color(image, intersection, origin_img, size, transform)
        else:
            continue

        if intersection is not None:
            distance = np.linalg.norm(intersection - origin)
            if distance < min_distance and distance > min_valid_distance:
                min_distance = distance
                closest_intersection = intersection
                intersection_color = color

    return closest_intersection, intersection_color

def get_image_color(image, intersection, origin_img, size, transform):
    if transform and 'rotate' in transform:
        angle = -np.radians(transform['rotate'])
        rotation_matrix = np.array([[np.cos(angle), -np.sin(angle)], [np.sin(angle), np.cos(angle)]])
        intersection = np.dot(rotation_matrix, intersection)

    x = int((intersection[0] - origin_img[0]) / size[0] * (image.width-1))
    y = int((intersection[1] - origin_img[1]) / size[1] * (image.height-1))

    if 0 <= x < image.width and 0 <= y < image.height:
        return image.getpixel((x, y))

    return None

def intersect_ray_circle(origin, direction, center, radius):
    oc = origin - center
    a = np.dot(direction, direction)
    b = 2.0 * np.dot(oc, direction)
    c = np.dot(oc, oc) - radius * radius
    discriminant = b * b - 4 * a * c

    if discriminant < 0:
        return None

    t1 = (-b - math.sqrt(discriminant)) / (2.0 * a)
    t2 = (-b + math.sqrt(discriminant)) / (2.0 * a)

    if t1 >= 0:
        return origin + t1 * direction
    if t2 >= 0:
        return origin + t2 * direction

    return None

def intersect_ray_rect(origin, direction, rect_origin, size, transform):
    # Transform the ray if the rectangle has a rotation
    if transform and 'rotate' in transform:
        angle = np.radians(transform['rotate'])
        rotation_matrix = np.array([[np.cos(angle), -np.sin(angle)], [np.sin(angle), np.cos(angle)]])
        inv_rotation_matrix = np.linalg.inv(rotation_matrix)
        origin = np.dot(inv_rotation_matrix, origin)
        direction = np.dot(inv_rotation_matrix, direction)

    inv_dir = 1 / direction
    t1 = (rect_origin[0] - origin[0]) * inv_dir[0]
    t2 = (rect_origin[0] + size[0] - origin[0]) * inv_dir[0]
    t3 = (rect_origin[1] - origin[1]) * inv_dir[1]
    t4 = (rect_origin[1] + size[1] - origin[1]) * inv_dir[1]

    tmin = max(min(t1, t2), min(t3, t4))
    tmax = min(max(t1, t2), max(t3, t4))

    if tmax < 0 or tmin > tmax:
        return None

    intersection = origin + tmin * direction if tmin >= 0 else origin + tmax * direction

    # Transform the intersection point back if the rectangle has a rotation
    if transform and 'rotate' in transform:
        intersection = np.dot(rotation_matrix, intersection)

    return intersection


if __name__ == "__main__":
    filename = "Scenes/flatland_intro.svg"
    elements = read_svg_file(filename)

    fig, ax = plt.subplots()
    fig, ax = draw_elements(fig, ax, elements)
    ax.invert_yaxis()  # Invert the y-axis to flip the drawing vertically
    ax.autoscale()
    ax.set_aspect('equal', adjustable='box')
    plt.show()